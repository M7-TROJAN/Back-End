# Robust Architecture: Myrtille Manager (Windows Service) + Web API

هذا مخطط ونسخة جاهزة "النسخة الجامدة" التي طلبتها: تطبيق **Worker Service** مسؤول عن فحص/تثبيت/إلغاء تثبيت Myrtille، و **Web API** خفيف (frontend) يتعامل مع الـ Worker عبر HTTP (داخل نفس الجهاز أو شبكة) — بهذه الطريقة تفصل صلاحيات الإدارة عن الـ Web App.

----

## goals

- فصل صلاحيات التثبيت عن الـ Web App
- Manager يعمل كـ Windows Service (يعمل بصلاحيات SYSTEM أو مستخدم Administrator)
- Web API مجرد واجهة (لا تقوم بتثبيت بنفسها)
- استخدام Options pattern + DataAnnotations
- استخدام HttpClientFactory
- Handling robust: timeouts, cancellation, retries, logs
- exposed API: status, trigger install/uninstall, get logs

----

## project layout (suggested solution)

```
MyrtilleSolution
├─ src
│  ├─ Myrtille.Shared (classlib)         <-- contracts, options, DTOs
│  ├─ Myrtille.Manager (worker)         <-- Windows Service / Worker + HTTP endpoints
│  └─ Myrtille.Web (aspnet core webapi) <-- public Web UI/API that calls Manager
└─ deploy
   └─ scripts (install-service.ps1, etc.)
```

----

## design notes

- **Manager** (Worker) runs as Windows Service (`UseWindowsService()`), exposes a small HTTP API (Kestrel) bound to `localhost:5005` by default for control.
- **Web** calls Manager via `http://localhost:5005` (or remote host if allowed) to request install/uninstall or read status.
- Manager owns MSI execution; because it runs as a service it can run under SYSTEM or an Administrator account and call `msiexec` safely.
- Manager maintains an internal state machine (NotInstalled | Installing | Installed | Uninstalling | Error).
- Use structured logging and health endpoints.
- Use `IOptions<MyrtilleOptions>` with validation and `ValidateOnStart` in both projects (Manager must validate at startup).

----

## Important security & operational notes

- **Do NOT** run the Manager as part of an IIS worker process. Use Windows Service or dedicated machine.
- Ensure the Manager service account has rights to run installers and access the MSI path.
- Consider protecting the Manager control endpoints (e.g., TLS + localhost only OR mutual TLS or API key) — by default we bind to `localhost`.
- For production, prefer running Manager on the same host as Myrtille and expose only localhost to web app.

----

## 1) Shared: `Myrtille.Shared` (C#)

`MyrtilleOptions.cs`

```csharp
using System.ComponentModel.DataAnnotations;

namespace Myrtille.Shared;

public class MyrtilleOptions
{
    public const string SectionName = "Myrtille";

    [Required]
    [Url]
    public string BaseUrl { get; set; } = default!; // e.g. http://localhost:9090/Myrtille

    [Required]
    [Url]
    public string ApiBaseUrl { get; set; } = default!; // e.g. http://localhost:9009/MyrtilleAdmin/ConnectionService

    [Required]
    [RegularExpression(@"^\/.*$", ErrorMessage = "ApiPath must start with '/'")]
    public string ApiPath { get; set; } = default!;

    public bool AllowRemoteClipboard { get; set; } = true;
    public bool AllowFileTransfer { get; set; } = true;
    public bool AllowPrintDownload { get; set; } = false;
    public bool AllowAudioPlayback { get; set; } = true;

    [Range(1, 10)]
    public int MaxActiveGuests { get; set; } = 2;

    [Required]
    public InstallerOptions Installer { get; set; } = new InstallerOptions();
}

public class InstallerOptions
{
    [Required]
    [RegularExpression(@"^.*\.msi$", ErrorMessage = "MsiPath must end with .msi")]
    public string MsiPath { get; set; } = "Myrtille_Setup.msi";

    [Range(1, 65535)]
    public int ServicesPort { get; set; } = 9090;

    [Range(1, 65535)]
    public int AdminPort { get; set; } = 9009;

    public bool Ssl { get; set; } = true; // use bool instead of int
    public bool PdfPrinter { get; set; } = true;
    public bool SessionUrl { get; set; } = true;

    public InstallScope InstallScope { get; set; } = InstallScope.CurrentUser;
}

public enum InstallScope
{
    CurrentUser = 0,
    Machine = 1
}
```

`InstallerState.cs`

```csharp
namespace Myrtille.Shared;

public enum InstallerState
{
    Unknown,
    NotInstalled,
    Installing,
    Installed,
    Uninstalling,
    Error
}
```

`IInstallerManager.cs` (contract between Web and Manager)

```csharp
namespace Myrtille.Shared;

public interface IInstallerManager
{
    Task<InstallerState> GetStateAsync(CancellationToken ct = default);
    Task TriggerInstallAsync(CancellationToken ct = default);
    Task TriggerUninstallAsync(CancellationToken ct = default);
}
```

----

## 2) Manager (Worker): `Myrtille.Manager`

### Overview

- Host a Generic Host with `UseWindowsService()`.
- Run a background worker to reconcile desired state (optional), and also expose minimal HTTP API for control/status.

### `Program.cs` (Manager)

```csharp
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Myrtille.Shared;

var builder = Host.CreateDefaultBuilder(args)
    .UseWindowsService() // when deployed
    .ConfigureAppConfiguration((ctx, cfg) => {
        // default config providers (appsettings.json, env, etc.)
    })
    .ConfigureServices((context, services) => {
        services.AddOptions<MyrtilleOptions>()
            .BindConfiguration(MyrtilleOptions.SectionName)
            .ValidateDataAnnotations()
            .ValidateOnStart();

        services.AddSingleton<IInstallerManager, InstallerManager>();
        services.AddHostedService<InstallerBackgroundService>();

        services.AddHttpClient();

        // Add Kestrel for control API
        services.AddHostedService<ControlApiHostedService>();
    })
    .Build();

await builder.RunAsync();
```

### `InstallerManager.cs` (core manager logic)

```csharp
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Myrtille.Shared;
using System.Diagnostics;

public class InstallerManager : IInstallerManager
{
    private readonly ILogger<InstallerManager> _logger;
    private readonly MyrtilleOptions _opts;
    private volatile InstallerState _state = InstallerState.Unknown;

    public InstallerManager(ILogger<InstallerManager> logger, IOptions<MyrtilleOptions> opts)
    {
        _logger = logger;
        _opts = opts.Value;
    }

    public Task<InstallerState> GetStateAsync(CancellationToken ct = default)
    {
        return Task.FromResult(_state);
    }

    public Task TriggerInstallAsync(CancellationToken ct = default)
    {
        // schedule or run installation asynchronously
        _ = RunInstallAsync(ct);
        return Task.CompletedTask;
    }

    public Task TriggerUninstallAsync(CancellationToken ct = default)
    {
        _ = RunUninstallAsync(ct);
        return Task.CompletedTask;
    }

    private async Task RunInstallAsync(CancellationToken ct)
    {
        try
        {
            _state = InstallerState.Installing;
            var msi = ResolveMsiPath();
            var i = _opts.Installer;
            var args = $"/i \"{msi}\" /qn SERVICESPORT={i.ServicesPort} ADMINPORT={i.AdminPort} SSL={(i.Ssl ? 1 : 0)} PDFPRINTER={(i.PdfPrinter ? 1 : 0)} SESSIONURL={(i.SessionUrl ? 1 : 0)} INSTALLSCOPE={(int)i.InstallScope}";

            await RunElevatedProcessAsync("msiexec.exe", args, ct);

            // verify installation by probing
            bool ok = await ProbeAdminEndpointAsync(ct);
            _state = ok ? InstallerState.Installed : InstallerState.Error;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Install failed");
            _state = InstallerState.Error;
        }
    }

    private async Task RunUninstallAsync(CancellationToken ct)
    {
        try
        {
            _state = InstallerState.Uninstalling;
            var msi = ResolveMsiPath();
            var args = $"/x \"{msi}\" /qn";
            await RunElevatedProcessAsync("msiexec.exe", args, ct);
            _state = InstallerState.NotInstalled;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Uninstall failed");
            _state = InstallerState.Error;
        }
    }

    private Task RunElevatedProcessAsync(string exe, string args, CancellationToken ct)
    {
        // Because manager runs as service with appropriate rights, we start process normally
        var psi = new ProcessStartInfo(exe, args)
        {
            UseShellExecute = false,
            CreateNoWindow = true,
            RedirectStandardOutput = true,
            RedirectStandardError = true
        };

        var tcs = new TaskCompletionSource<object?>();
        var proc = new Process { StartInfo = psi, EnableRaisingEvents = true };
        proc.Exited += (s, e) => {
            if (proc.ExitCode == 0) tcs.TrySetResult(null);
            else tcs.TrySetException(new InvalidOperationException($"ExitCode={proc.ExitCode}"));
            proc.Dispose();
        };

        try
        {
            proc.Start();
            _ = proc.StandardOutput.ReadToEndAsync();
            _ = proc.StandardError.ReadToEndAsync();
        }
        catch (Exception ex)
        {
            tcs.TrySetException(ex);
        }

        ct.Register(() => {
            try { if (!proc.HasExited) proc.Kill(); } catch {};
        });

        return tcs.Task;
    }

    private string ResolveMsiPath()
    {
        var path = _opts.Installer.MsiPath;
        if (Path.IsPathRooted(path)) return path;
        var candidate = Path.Combine(AppContext.BaseDirectory, path);
        if (File.Exists(candidate)) return candidate;
        return Path.GetFullPath(Path.Combine(AppContext.BaseDirectory, "..", "..", path));
    }

    private async Task<bool> ProbeAdminEndpointAsync(CancellationToken ct)
    {
        try
        {
            using var client = new HttpClient { Timeout = TimeSpan.FromSeconds(3) };
            var url = _opts.ApiBaseUrl.TrimEnd('/') + _opts.ApiPath;
            var r = await client.GetAsync(url, ct);
            return r.IsSuccessStatusCode;
        }
        catch { return false; }
    }
}
```

### `InstallerBackgroundService.cs`

```csharp
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

public class InstallerBackgroundService : BackgroundService
{
    private readonly ILogger<InstallerBackgroundService> _logger;
    private readonly IInstallerManager _manager;

    public InstallerBackgroundService(ILogger<InstallerBackgroundService> logger, IInstallerManager manager)
    {
        _logger = logger;
        _manager = manager;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("Installer background service started");

        // optional: reconcile desired state on startup
        var state = await _manager.GetStateAsync(stoppingToken);
        if (state == InstallerState.NotInstalled)
        {
            // don't auto install by default; require explicit trigger
            _logger.LogInformation("Not installed; waiting for manual install command");
        }

        // Just block here; control happens via HTTP endpoints below.
        await Task.Delay(Timeout.Infinite, stoppingToken);
    }
}
```

### `ControlApiHostedService.cs` (exposes minimal HTTP control API)

```csharp
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.DependencyInjection;

public class ControlApiHostedService : IHostedService
{
    private IHost? _webHost;
    private readonly IServiceProvider _services;

    public ControlApiHostedService(IServiceProvider services)
    {
        _services = services;
    }

    public Task StartAsync(CancellationToken cancellationToken)
    {
        _webHost = Host.CreateDefaultBuilder()
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseKestrel(options => options.ListenLocalhost(5005));
                webBuilder.ConfigureServices(services =>
                {
                    services.AddRouting();
                    services.AddSingleton(_services.GetRequiredService<IInstallerManager>());
                });
                webBuilder.Configure(app =>
                {
                    var installer = app.ApplicationServices.GetRequiredService<IInstallerManager>();

                    app.UseRouting();

                    app.UseEndpoints(endpoints =>
                    {
                        endpoints.MapGet("/status", async ctx =>
                        {
                            var s = await installer.GetStateAsync();
                            await ctx.Response.WriteAsJsonAsync(new { state = s.ToString() });
                        });

                        endpoints.MapPost("/install", async ctx =>
                        {
                            await installer.TriggerInstallAsync();
                            ctx.Response.StatusCode = 202;
                        });

                        endpoints.MapPost("/uninstall", async ctx =>
                        {
                            await installer.TriggerUninstallAsync();
                            ctx.Response.StatusCode = 202;
                        });
                    });
                });
            })
            .Build();

        return _webHost.StartAsync(cancellationToken);
    }

    public async Task StopAsync(CancellationToken cancellationToken)
    {
        if (_webHost != null) await _webHost.StopAsync(cancellationToken);
    }
}
```

----

## 3) Web (Myrtille.Web) — the front-end web app that calls Manager

`Program.cs` (Web API / MVC)

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpClient("manager", client =>
{
    client.BaseAddress = new Uri(builder.Configuration["Manager:BaseUrl"] ?? "http://localhost:5005");
    client.Timeout = TimeSpan.FromSeconds(10);
});

builder.Services.AddControllersWithViews();
var app = builder.Build();
app.MapGet("/api/installer/status", async (IHttpClientFactory factory) =>
{
    var client = factory.CreateClient("manager");
    var r = await client.GetAsync("/status");
    return Results.Content(await r.Content.ReadAsStringAsync(), "application/json");
});

app.MapPost("/api/installer/install", async (IHttpClientFactory factory) =>
{
    var client = factory.CreateClient("manager");
    var r = await client.PostAsync("/install", null);
    return Results.StatusCode((int)r.StatusCode);
});

app.MapPost("/api/installer/uninstall", async (IHttpClientFactory factory) =>
{
    var client = factory.CreateClient("manager");
    var r = await client.PostAsync("/uninstall", null);
    return Results.StatusCode((int)r.StatusCode);
});

app.Run();
```

----

## 4) Deployment & Running

### Local debugging (Manager):
- You can run Manager under your user account for testing: `dotnet run --project src/Myrtille.Manager`
- For production, publish and install as Windows Service.

### To install as Windows Service (example using PowerShell):
`deploy/scripts/install-service.ps1`

```powershell
$exe = "C:\path\to\Myrtille.Manager.exe"
New-Service -Name "MyrtilleManager" -BinaryPathName "$exe" -Description "Myrtille Manager Service" -DisplayName "Myrtille Manager" -StartupType Automatic
Start-Service MyrtilleManager
```

(Or use sc.exe / NSSM / WiX service installer depending on preferences.)

----

## 5) Why this is "النسخة الجامدة"

- Manager runs with the right privileges (Windows Service) — safe for installers
- Web app is unprivileged and only calls control API
- Clean separation of concerns
- State machine, control API, and background worker allow monitoring and safe execution
- Logging & validation on startup reduce runtime surprises

----

## 6) Next steps I can do for you (pick any):
- Generate full Visual Studio solution files and all source files ready to paste/run.
- Add authentication to control API (API key, mTLS, or Windows-only loopback)
- Add health checks and Prometheus metrics for Manager
- Add graceful retries & exponential backoff for probe logic
- Add unit tests + integration tests (local MSI stub)

قول أي واحدة تفضل نبدأ بيها وأنا أجيب لك الملفات الجاهزة.

