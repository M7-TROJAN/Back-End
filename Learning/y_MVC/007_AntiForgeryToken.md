الـ Anti-Forgery Token هو إجراء أمني بيتم استخدامه في تطبيقات الويب عشان يحمي من هجمات الـ Cross-Site Request Forgery (CSRF).

يعني إيه CSRF؟

هجمات الـ CSRF بتحصل لما مستخدم معاه session مفتوح (يعني عامل login) على موقع معين، ويقوم موقع خبيث بإرسال طلبات باسم المستخدم ده للموقع التاني من غير علمه. الموقع الشرعي بينفذ الطلبات لإنه بيثق في الـ session المفتوح، وده ممكن يتسبب في تنفيذ عمليات غير مصرح بها.

ليه بنستخدم الـ Anti-Forgery Token؟

الـ Anti-Forgery Token هو رمز (token) فريد بيتولد لكل طلب (request) للمستخدم، وبيتم تضمينه في الصفحات اللي فيها عمليات خطيرة (زي النماذج - forms). لما المستخدم يرسل بيانات (مثلاً من خلال POST request)، السيرفر بيتأكد إن الـ token اللي جاي مع الطلب هو نفسه اللي تم إرساله مع الصفحة الأصلية، وده بيضمن إن الطلب جاي من المستخدم الشرعي مش من موقع خارجي خبيث.

ليه بنستخدم [ValidateAntiForgeryToken] مع [HttpPost]؟

بنستخدم الـ attribute ده في الأكشنات اللي بتستقبل بيانات (زي POST requests) عشان نتحقق من إن الـ Anti-Forgery Token اللي جاي مع الطلب هو نفسه اللي تم إرساله في الصفحة. لو الـ token مش موجود أو غلط، السيرفر بيرفض الطلب وبيعتبره غير آمن.

خطوات عمل الـ Anti-Forgery Token:

1. لما المستخدم يفتح الصفحة، بيتم إنشاء token وتضمينه في الصفحة (عادةً داخل نموذج - form).
2. لما المستخدم يرسل البيانات من خلال POST request، الـ token بيتبعت مع الطلب.
3. السيرفر بيتحقق من صحة الـ token. لو كان صحيح، بينفذ الطلب. لو مش صحيح، بيرفض الطلب لحمايته.

مثال عملي:
```javascript
[HttpPost]
[ValidateAntiForgeryToken]
public IActionResult SubmitForm(MyModel model)
{
    if (ModelState.IsValid)
    {
        // Logic to process form data
    }
    return View(model);
}
```
هنا، الـ ValidateAntiForgeryToken بيتحقق من صحة الـ token اللي جاي مع الطلب. لو الـ token سليم، الأكشن هيكمل تنفيذ الكود.




The **AntiForgeryToken** is a security feature in ASP.NET Core (and earlier versions of ASP.NET MVC) designed to prevent **Cross-Site Request Forgery (CSRF)** attacks. 

### What is CSRF (Cross-Site Request Forgery)?
CSRF is an attack where a malicious website tricks a user's browser into making unwanted requests to a different site where the user is authenticated. The attack is successful if the user is logged in and their session or credentials are valid.

For example, let's say a user is logged into a banking application. If they visit a malicious website while still logged in, that site could trick the browser into making a harmful request (like transferring money) to the bank's website without the user's consent. This is possible because the browser automatically includes the user's authentication cookies with the request.

### How does the AntiForgeryToken Work?
To mitigate CSRF attacks, ASP.NET uses **anti-forgery tokens**. These tokens ensure that the requests are coming from legitimate users who have access to the form and are not generated by an external source.

- **Server-Side Generation:** When a form is rendered, ASP.NET Core generates a unique anti-forgery token and stores it in two places:
    - In a hidden field within the form (`<input type="hidden" name="__RequestVerificationToken" />`).
    - In a cookie that is also sent to the browser.
  
- **Client-Side Submission:** When the form is submitted, both the hidden field value and the cookie are sent back to the server.

- **Server-Side Validation:** The server validates the token by checking if the values of the hidden field and the cookie match. If they match, it is assumed that the request is legitimate and originated from the same site. If they don't match, the server rejects the request, protecting the application from CSRF attacks.

### Example of Anti-Forgery Token in a Razor View:
```html
<form asp-action="SubmitForm" method="post">
    @Html.AntiForgeryToken() <!-- Generates hidden input with token -->
    <!-- Other form fields here -->
    <input type="submit" value="Submit">
</form>
```
This adds a hidden field to the form:
```html
<input name="__RequestVerificationToken" type="hidden" value="random-token-value" />
```

### [ValidateAntiForgeryToken] Attribute
The `[ValidateAntiForgeryToken]` attribute is used in **POST** actions to tell ASP.NET Core to check that the anti-forgery token in the request matches the one generated for that user.

```csharp
[HttpPost]
[ValidateAntiForgeryToken] // This ensures that the token is validated
public IActionResult SubmitForm(MyViewModel model)
{
    if (ModelState.IsValid)
    {
        // Process the form submission
    }
    return View(model);
}
```

- When the user submits the form, the token from the hidden field and the token stored in the cookie are compared by the server.
- If the tokens match, the server processes the request.
- If the tokens don't match (or are missing), the request is rejected, protecting the application from a possible CSRF attack.

### Why Should You Use AntiForgeryToken?
You should use `@Html.AntiForgeryToken()` and `[ValidateAntiForgeryToken]` in your forms because:
1. **Prevents CSRF Attacks**: It ensures that the form submissions and AJAX requests are from the legitimate users and not from malicious third-party websites.
2. **Security Best Practice**: It adds a layer of security to your web forms by verifying that the request originated from the same site.
3. **Default in ASP.NET Core**: ASP.NET Core has built-in support for anti-forgery tokens, making it easy to implement and is considered a best practice.

### Example of Anti-Forgery Token in an AJAX Request:
If you're making an AJAX request (like in your original code), you also need to include the anti-forgery token in the AJAX request's payload:

```javascript
$.ajax({
    url: '/YourController/YourAction',
    type: 'POST',
    data: {
        '__RequestVerificationToken': $('input[name="__RequestVerificationToken"]').val(), // Add token to data
        yourData: yourData
    },
    success: function(response) {
        // Handle success
    },
    error: function(error) {
        // Handle error
    }
});
```

### Summary:
- **`@Html.AntiForgeryToken()`**: Generates the anti-forgery token and adds it to the form.
- **`[ValidateAntiForgeryToken]`**: Validates the anti-forgery token on the server-side to ensure that the request is coming from a trusted source.
- This combination helps to prevent **CSRF attacks**, a common security vulnerability in web applications.


--- 
هشرح لنفسي تاني برضو 
---
الـ AntiForgeryToken هو نوع من الحماية في تطبيقات الويب يستخدم لمنع هجمات تُسمى “Cross-Site Request Forgery” أو CSRF. دي نوع من الهجمات اللي فيها ممكن مهاجم يستغل تسجيل دخول المستخدم أو صلاحياته عشان ينفذ طلبات ضده بدون ما المستخدم يعرف.

ازاي بيشتغل الـ AntiForgeryToken؟

لما المستخدم يفتح صفحة فيها فورم (form)، الـ AntiForgeryToken بيضيف توكين سري (كود أو رمز عشوائي) في الـ HTML بتاع الصفحة. لما المستخدم يبعت الفورم للسيرفر، السيرفر بيقارن التوكين ده مع التوكين اللي عنده وبيتأكد إنهم متطابقين. لو التوكين مش موجود أو مش متطابق، السيرفر بيمنع الطلب ويعتبره غير آمن.

مثال على الاستخدام

في تطبيقات الـ ASP.NET MVC أو ASP.NET Core، ممكن تستخدم @Html.AntiForgeryToken() في الفيو (view) عشان تضيف التوكين ده تلقائيًا للفورم.

مثال في كود الفيو:
```cshtml
<form method="post">
    @Html.AntiForgeryToken()
    <input type="text" name="username" />
    <button type="submit">Submit</button>
</form>
```
وفي الكنترولر (controller)، ممكن تضيف [ValidateAntiForgeryToken] كديكور على الأكشن اللي بيعالج الطلب:
```csharp
[HttpPost]
[ValidateAntiForgeryToken]
public IActionResult SubmitForm(UserModel model)
{
    // تنفيذ الكود الخاص بالفورم
}
```
ليه هو مهم؟

الـ AntiForgeryToken بيحمي المستخدمين من هجمات CSRF، وده بيساهم في رفع مستوى الأمان في التطبيق، لأنه بيتأكد إن الطلبات اللي بتيجي للسيرفر جاية من المستخدم نفسه مش من جهة خارجية بتحاول تستغل صلاحيته.

وفي طريقة تانية برضو معروفة 

```cshtml
@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery antiforgery

<form method="post">

<input type="hidden" name="__RequestVerificationToken" value="@antiforgery.GetAndStoreTokens(Context).RequestToken" />
    <input type="text" name="username" />
    <button type="submit">Submit</button>
</form>
```

الطريقتين اللي بيوصلوا لنفس الهدف وهو حماية الفورم من هجمات CSRF، ولكن في فرق بسيط بينهم في طريقة الاستخدام:

الطريقة الأولى: `@Html.AntiForgeryToken()`

دي طريقة مختصرة ومباشرة، بتضيف التوكين للفورم بشكل تلقائي بدون الحاجة لأي إعداد إضافي. لما تستخدم `@Html.AntiForgeryToken()` ال `ASP.NET Core` بتتولى إضافة التوكين كـ `<input type="hidden">` تلقائيًا في الفورم، وده بيسهّل الاستخدام ويقلل الأكواد المطلوبة.

الطريقة الثانية: استخدام `IAntiforgery` مباشرة

لما بتستخدم `IAntiforgery` وبتحقنه عن طريق `@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery antiforgery` ، بتحتاج تكتب كود عشان تجيب التوكين وتضيفه للفورم يدويًا:
```cshtml
<input type="hidden" name="__RequestVerificationToken" value="@antiforgery.GetAndStoreTokens(Context).RequestToken" />
```
ده ممكن يكون مفيد لو عندك احتياجات خاصة أو لو عايز تتحكم في كيفية توليد التوكين أو استخدامه.

أيهما أفضل؟

 • الطريقة الأولى (@Html.AntiForgeryToken()) هي الأفضل في معظم الحالات لأنها أسهل وأوضح وبتغنيك عن كتابة أكواد إضافية.
 • الطريقة الثانية (باستخدام IAntiforgery) ممكن تكون مفيدة لو عندك احتياجات خاصة أو لو بتشتغل في سيناريو معقد مش بيتناسب مع الطريقة المختصرة.

في العموم، لو مش محتاج تخصيص معين، يفضل استخدام @Html.AntiForgeryToken().

