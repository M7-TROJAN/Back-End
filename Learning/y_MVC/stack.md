## Objective
Given an of N integers array, print the Next Greater Element (NGE) for every element.
• Please use the appropriate data structure that helps you to minimize the code.
- Input: 
```
arr[] = [ 13 , 7, 6 , 12 ]
```
Output:
```
    13 –> -1
    7 –> 12
    6 –> 12
    12 –> -1
```
Explanation: 
    13 and 12 don’t have any element greater than them
    present on the right side
---
 خلينا نشرح الفكرة من الأول وبطريقة بسيطة، بحيث نفهم السؤال والحل خطوة خطوة.

1. السؤال ببساطة:

عندك مصفوفة عبارة عن أرقام. لكل رقم فيها، مطلوب منك تعرف:
- إيه هو أول رقم أكبر منه موجود على يمينه؟
- لو مفيش أي رقم أكبر منه على يمينه، تكتب -1

2. المثال الي في المسألة مثلا :
 - العنصر الأول (13):
الأرقام على يمين 13 هي: 7 و 6 و 12 نلاحظ ان مفيش أي رقم أكبر من 13، إذًا الناتج = -1.
 - العنصر الثاني (7):
الأرقام على يمين 7 هي: 6 و 12 نلاحظ ان أول رقم أكبر من 7 هو 12، إذًا الناتج = 12.
 - العنصر الثالث (6): 
الأرقام على يمين 6 هي: 12 أول رقم أكبر من 6 والرقم الوحيد اصلا هو 12، إذًا الناتج = 12.
 - العنصر الرابع (12): مفيش أي أرقام على يمين 12. إذًا الناتج = -1.

الناتج النهائي:

```
13 -> -1
7  -> 12
6  -> 12
12 -> -1
```
3. إزاي نحلها بقي بالكود؟

بص هو في طريقة “بديهية” لكنها مش فعالة جدًا، وطريقة “ذكية” باستخدام هيكل بيانات `Stack` وده الي الدكتور عاوزه اصلا.

الطريقة البديهية (نمر على كل العناصر):

 1. نبدأ من أول عنصر.
 2. لكل عنصر، نبص على الأرقام اللي بعده في المصفوفة، ونشوف أول رقم أكبر منه.
 3. إذا لقينا رقم أكبر، نسجله كـ `NGE` لو مش موجود، نكتب -1.
 4. نكرر ده لكل عنصر.

الطريقة الذكية (`Stack`):

بدل ما نبحث على الأرقام بطريقة مباشرة، نستخدم `Stack` علشان نحفظ الأرقام اللي ممكن تكون إجابة، وده يخلي الحل أسرع.
 - نمشي على الأرقام من اليمين للشمال.
 - كل مرة نحفظ في الـ Stack العناصر اللي محتاجينها فقط.
 - نستخدم قمة الـ Stack لمعرفة الرقم الأكبر.




## **الحل الأول: الطريقة البديهية**

### الفكرة:
- نمر على كل عنصر في المصفوفة.
- لكل عنصر، نبص على الأرقام اللي على يمينه ونبحث عن أول رقم أكبر منه.
- لو لقينا رقم أكبر، نخزنه. لو مالقيناش، نخزن \(-1\).

### الكود (C++):
```cpp
#include <iostream>
#include <vector>
using namespace std;

void printNextGreaterElement(vector<int>& arr) {
    int n = arr.size();

    for (int i = 0; i < n; i++) {
        int nge = -1; // الافتراض: مفيش رقم أكبر
        for (int j = i + 1; j < n; j++) {
            if (arr[j] > arr[i]) { // أول رقم أكبر
                nge = arr[j];
                break;
            }
        }
        cout << arr[i] << " -> " << nge << endl;
    }
}

int main() {
    vector<int> arr = {13, 7, 6, 12};
    printNextGreaterElement(arr);
    return 0;
}
```

---

### شرح الكود خطوة بخطوة وبراحة وعلي الهادي يازبادي:
1. **اندخل على العنصر الأول:**
 - نفترض أن الناتج = \(-1\). بنفترض ان مفيش رقم اكبر منه يعني
 - ندور عن أول عنصر أكبر على يمين العنصر الحالي باستخدام حلقة `for`.
 - لو لقينا عنصر أكبر، بنحدث الناتج `nge` ونخرج من اللوب الداخلية.

2. **الطباعة:**
   - لكل عنصر في المصفوفة، بنطبع العنصر مع الـعنصر الاكبر منه **Next Greater Element (NGE)**.

---

### الناتج:
```
13 -> -1
7 -> 12
6 -> 12
12 -> -1
```

---

### التعقيد الزمني:
- الناس الي بتدرس cs512 هما الي هيفهمو النقطة دي وهو ال `time complexity` وهل الحل ده كويس ولا سيء
- هنلاحظ ان في أسوأ الحالات، بنحتاج أننا نبحث لكل عنصر عن كل العناصر الي موجودة على يمينه.   
- **التعقيد الزمني:** \(O(n^2)\) (بطيء نسبيًا للمصفوفات الكبيرة).

---

## **الحل الثاني: الطريقة الذكية باستخدام Stack**
دي الطريقة الي الدكتور عاوزها اصلا
### الفكرة:
- بنمر على المصفوفة **من اليمين ل الشمال** (بدلًا من الشمال إلى اليمين).  
- نستخدم **Stack** كهيكل بيانات نحفظ فيه العناصر الي ممكن أن تكون إجابات.  
- بنحدد الإجابة لكل عنصر من خلال العنصر الموجود على قمة الـ Stack.

---

### الكود (C++):
```cpp
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

void printNextGreaterElement(vector<int>& arr) {
    int n = arr.size();
    vector<int> nge(n); // لتخزين النتائج
    stack<int> s;       // لتخزين العناصر المحتملة

    for (int i = n - 1; i >= 0; i--) { // بنلف من اليمين للشمال

        while (!s.empty() && s.top() <= arr[i]) { // حذف كل العناصر الاصغر او المساوية للعنصر الحالي
            s.pop();
        }

        nge[i] = s.empty() ? -1 : s.top(); // لو الستاك فاضية ده معناه مفيش عنصر اكبر من العنصر الي بنلف عليه ده فبنحط -1

        s.push(arr[i]); // ضيف العنصر الحالي للستاك
    }

    for (int i = 0; i < n; i++) { // بعد ما تخلص كل الهري الي فوق ده اطبع النتائج
        cout << arr[i] << " -> " << nge[i] << endl;
    }
}

int main() {
    vector<int> arr = {13, 7, 6, 12};
    printNextGreaterElement(arr);
    return 0;
}
```

---

### شرح الكود خطوة بخطوة:
1. **إنشاء Stack:**
 - نستخدم الـ Stack لحفظ العناصر التي يمكن أن تكون **Next Greater Element** لعناصر أخرى.

2. **المرور على المصفوفة من اليمين إلى الشمال:**
 - لو كان العنصر الحالي أكبر من أو يساوي العناصر في قمة الـ Stack، نحذف العناصر دي لأنها مبقتش مفيدة لينا خلاص.
 - لو كانت الـ Stack فاضية بعد الحذف، فده يعني أنه مفيش عنصر أكبر على يمين العنصر الحالي، وبالتالي الناتج = \(-1\).
 - لو مكانتش فاضية، ده معناه ان العنصر الموجود على قمة الـ Stack هو **Next Greater Element**.

3. **إضافة العنصر الحالي إلى الـ Stack:**
 - نضيف العنصر الحالي لأنه ممكن يكون **NGE** لعناصر على يساره.

4. **الطباعة:**
---

### الناتج:
```
13 -> -1
7 -> 12
6 -> 12
12 -> -1
```

---

### التعقيد الزمني:
- كل عنصر بيُدخَل وبيتحذَف مرة واحدة بس من الـ Stack.
- **التعقيد الزمني:** \(O(n)\) (أسرع بكتييييييييييييييييييير من الطريقة الاولي).

---

## **مقارنة بين الحلين:**

| الطريقة                 | العبيطة  | باستخدام Stack |
|-------------------------|------------------------|----------------|
| **سهولة الفهم**         | بسيطة وواضحة         | أصعب قليلًا   |
| **التعقيد الزمني**      | \(O(n^2)\)            | \(O(n)\)      |
| **الأداء مع المصفوفات الكبيرة** | بطيئة جدًا            | سريعة جدًا    |

---
