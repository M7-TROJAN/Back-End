### Understanding Table per Type (TPT) in Entity Framework Core

#### Introduction to Table per Type (TPT)

In the Table per Type (TPT) approach, each class in an inheritance hierarchy is mapped to its own database table. The base class and each derived class have separate tables, and the derived class tables include a foreign key that references the primary key of the base class table. This approach ensures that each table contains only the columns that correspond to the properties of the respective class.

#### Example Scenario

Let's consider the following scenario, where you have a base class `Participant` and two derived classes `Individual` and `Corporate`:

```csharp
public class Participant
{
    public int Id { get; set; }

    public string? FName { get; set; }

    public string? LName { get; set; }

    [RegularExpression("^[fm]$", ErrorMessage = "Gender must be 'f' or 'm'")]
    public char Gender { get; set; }

    public ICollection<Section> Sections { get; set; } = new List<Section>();
}

public class Individual : Participant
{
    public string University { get; set; }
    public int YearOfGraduation { get; set; }
    public bool IsIntern { get; set; }
}

public class Corporate : Participant
{
    public string Company { get; set; }
    public string JobTitle { get; set; }
}
```

#### Configuring TPT in EF Core

To configure TPT in Entity Framework Core, you need to specify that each derived type should be mapped to its own table using the `ToTable` method inside the `OnModelCreating` method of your `DbContext`:

```csharp
public class AppDbContext : DbContext
{
    public DbSet<Participant> Participants { get; set; }
    public DbSet<Individual> Individuals { get; set; }
    public DbSet<Corporate> Corporates { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Configuring TPT
        modelBuilder.Entity<Participant>().ToTable("Participants");
        modelBuilder.Entity<Individual>().ToTable("Individuals");
        modelBuilder.Entity<Corporate>().ToTable("Corporates");

        // Applying additional configurations if necessary
        modelBuilder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());
    }
}
```

#### How Tables Are Created in the Database

When using TPT, EF Core generates separate tables for each entity:

1. **Participants**: This table contains columns for `Id`, `FName`, `LName`, and `Gender`, which are common to all `Participant` entities.
2. **Individuals**: This table contains columns for `Id`, `University`, `YearOfGraduation`, and `IsIntern`. The `Id` column is both the primary key and a foreign key referencing the `Participants` table.
3. **Corporates**: This table contains columns for `Id`, `Company`, and `JobTitle`. Like `Individuals`, the `Id` column here is the primary key and a foreign key referencing the `Participants` table.

#### Example of Migration Generated by TPT

When you create a migration using the TPT approach, it will generate something like this:

```csharp
public partial class Initial : Migration
{
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.CreateTable(
            name: "Participants",
            columns: table => new
            {
                Id = table.Column<int>(type: "int", nullable: false),
                FName = table.Column<string>(type: "VARCHAR(50)", maxLength: 50, nullable: false),
                LName = table.Column<string>(type: "VARCHAR(50)", maxLength: 50, nullable: false),
                Gender = table.Column<string>(type: "CHAR(1)", maxLength: 1, nullable: false)
            },
            constraints: table =>
            {
                table.PrimaryKey("PK_Participants", x => x.Id);
                table.CheckConstraint("chk_Gender", "Gender IN ('f', 'm')");
            });

        migrationBuilder.CreateTable(
            name: "Individuals",
            columns: table => new
            {
                Id = table.Column<int>(type: "int", nullable: false),
                University = table.Column<string>(type: "nvarchar(max)", nullable: true),
                YearOfGraduation = table.Column<int>(type: "int", nullable: true),
                IsIntern = table.Column<bool>(type: "bit", nullable: true)
            },
            constraints: table =>
            {
                table.PrimaryKey("PK_Individuals", x => x.Id);
                table.ForeignKey(
                    name: "FK_Individuals_Participants_Id",
                    column: x => x.Id,
                    principalTable: "Participants",
                    principalColumn: "Id",
                    onDelete: ReferentialAction.Cascade);
            });

        migrationBuilder.CreateTable(
            name: "Corporates",
            columns: table => new
            {
                Id = table.Column<int>(type: "int", nullable: false),
                Company = table.Column<string>(type: "nvarchar(max)", nullable: true),
                JobTitle = table.Column<string>(type: "nvarchar(max)", nullable: true)
            },
            constraints: table =>
            {
                table.PrimaryKey("PK_Corporates", x => x.Id);
                table.ForeignKey(
                    name: "FK_Corporates_Participants_Id",
                    column: x => x.Id,
                    principalTable: "Participants",
                    principalColumn: "Id",
                    onDelete: ReferentialAction.Cascade);
            });
    }

    protected override void Down(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.DropTable(name: "Corporates");
        migrationBuilder.DropTable(name: "Individuals");
        migrationBuilder.DropTable(name: "Participants");
    }
}
```

#### Querying the Data

When querying data using the TPT strategy, EF Core automatically joins the tables and returns the appropriate data:

```csharp
using (var context = new AppDbContext())
{
    // Querying all Participants (base type properties only)
    var participants = context.Participants.ToList();

    // Querying Individuals (base type + derived type properties)
    var individuals = context.Individuals.ToList();

    // Querying Corporates (base type + derived type properties)
    var corporates = context.Corporates.ToList();
}
```

#### Key Points

- **TPT Inheritance**: Each entity in the inheritance hierarchy has its own table.
- **Separation of Data**: The base class table contains only base properties, while derived class tables contain derived properties.
- **Foreign Key Relationship**: Derived class tables have a foreign key relationship with the base class table.
- **Efficient Queries**: EF Core automatically handles the joins between tables when querying data.

#### Advantages of TPT

- **Normalized Database**: TPT results in a normalized database design where each table holds only relevant data.
- **Clear Separation**: The separation of base and derived data ensures clarity and prevents redundant data.

#### Disadvantages of TPT

- **Complex Queries**: Since data is spread across multiple tables, queries may require joins, making them more complex.
- **Performance**: TPT can lead to slower performance for certain queries, especially when working with a large number of derived types.